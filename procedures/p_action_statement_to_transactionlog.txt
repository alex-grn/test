CREATE OR REPLACE FUNCTION public.p_action_statement_to_transactionlog (
  id bigint,
  uid bigint
)
RETURNS text AS
$body$
declare 
   nID  bigint:=ID;
   nUID bigint:=UID;
   rec  record;
   sp   record;
   nTRANSACTIONLOGID bigint;
   nTRANSACTIONLOG_DOCSID bigint;
   nTRANSACTIONLOG_STAGESID bigint;
   next_num text;
begin
    for rec in (
        select a.ELECTCAMPAIGNID,
               a.JURPERSONSID,
               p.DOCTYPEID,
               p.DOCNUMB,
               p.DOCDATE,
               sum(COALESCE(ps.SUMMPAY,0)) as SUMM,
               ps.TYPICALOPERSID,
               count(ps.TYPICALOPERSID) OVER() as count_typ,
               p.ID as STATEMENT_HEADERID,
               a.ID as CASHDOCSID,
               t.name as TYPENAME
          from STATEMENT_HEADER p, 
               CASHDOCS a,
               STATEMENT ps,
               TYPICALOPERS t
         where p.id = nID 
           and a.id = p.CASHDOCSID
           and ps.STATEMENTHEADERID = p.ID
           and t.ID = ps.TYPICALOPERSID
      group by a.ELECTCAMPAIGNID,
               a.JURPERSONSID,
               p.DOCTYPEID,
               p.DOCNUMB,
               p.DOCDATE,
               ps.TYPICALOPERSID,
               p.ID,
               a.ID,
               t.name
    )
    LOOP
       update STATEMENT_HEADER p set status = '2' where p.ID = rec.STATEMENT_HEADERID;
       if rec.count_typ > 1 then raise using message = 'Для платежного поручения указаны разные типовые операции'; end if;
      --найдем заголовок, если нет его, то добавим
       BEGIN
         select t.ID 
           into STRICT nTRANSACTIONLOGID
           from TRANSACTIONLOG t 
          where t.ELECTCAMPAIGNID = rec.ELECTCAMPAIGNID 
            and t.JURPERSONSID = rec.JURPERSONSID;
       exception when no_data_found THEN 
          insert into transactionlog(uid,lid,electcampaignid,jurpersonsid)
                              values(nUID,P_SYSTEM_GEN_LID('TRANSACTIONLOG',nUID),rec.ELECTCAMPAIGNID,rec.JURPERSONSID) returning TRANSACTIONLOG.ID into nTRANSACTIONLOGID;
       end;
       
       --сгенерируем следующий номер
       select (max(t.transactionnumb::integer)+1)::text into next_num from TRANSACTIONLOG_DOCS t where t.transactionlogid = nTRANSACTIONLOGID;
       
       --создаем запись в журнале операций
       insert into TRANSACTIONLOG_DOCS(uid,lid,transactionlogid,transactionnumb,transactiondate,doctypeid,docnumb,docdate,docsum,typicalopersid,tponame)
       values(nUID,P_SYSTEM_GEN_LID('TRANSACTIONLOG_DOCS',nUID),nTRANSACTIONLOGID,COALESCE(next_num,'1'),rec.DOCDATE,rec.DOCTYPEID,rec.DOCNUMB,rec.DOCDATE,rec.SUMM,rec.TYPICALOPERSID,rec.TYPENAME) 
       returning TRANSACTIONLOG_DOCS.ID into nTRANSACTIONLOG_DOCSID;
       
       for sp in (
           select case when t.ACCOUNTDTID is not null then COALESCE(t.DTBUDGCLASSID,p.BUDGCLASSID) else null end as DTBUDGCLASSID,
                  case when t.ACCOUNTKTID is not null then COALESCE(t.KTBUDGCLASSID,p.BUDGCLASSID) else null end as KTBUDGCLASSID,
                  case when t.ACCOUNTKTID is not null then COALESCE(t.ECONCLASSKTID,p.ECONCLASSKTID) else null end as ECONCLASSKTID,
                  case when t.ACCOUNTDTID is not null then COALESCE(t.ECONCLASSDTID,p.ECONCLASSKTID) else null end as ECONCLASSDTID,
                  case when t.ACCOUNTDTID is not null then p.TYPEEXPID else null end as DTYPEEXPID,
                  case when t.ACCOUNTKTID is not null then p.TYPEEXPID else null end as KTYPEEXPID,
                  t.ACCOUNTDTID,
                  case when t.ACCOUNTDTID is not null then 1 else null end as dKFO,
                  case when t.ACCOUNTKTID is not null then 1 else null end as kKFO,
                  t.ACCOUNTKTID,
                  p.SUMMPAY as SUMM,
                  p.ID,
                  t.MEMORDERID 
             from STATEMENT p
             left join TYPICALOPERSPEC t on t.TYPICALOPERSID = p.TYPICALOPERSID
             left join DICACCS d on d.ID = t.ACCOUNTDTID 
            where p.STATEMENTHEADERID = nID
       )
       LOOP
           insert into TRANSACTIONLOG_STAGES(uid,lid,transactionlog_docsid,dtfinsecurity,dtbudgclassid,dteconclassktid,dttypeexpid,accountdtid,ktfinsecurity,ktbudgclassid,kteconclassktid,kttypeexpid,accountktid,summ,memorderid)
             values(nUID,P_SYSTEM_GEN_LID('TRANSACTIONLOG_STAGES',nUID),nTRANSACTIONLOG_DOCSID,sp.dKFO,sp.DTBUDGCLASSID,sp.ECONCLASSDTID,sp.DTYPEEXPID,sp.ACCOUNTDTID,sp.kKFO,sp.KTBUDGCLASSID,sp.ECONCLASSKTID,sp.KTYPEEXPID,sp.ACCOUNTKTID,sp.SUMM,sp.memorderid)
           returning TRANSACTIONLOG_STAGES.ID into nTRANSACTIONLOG_STAGESID;
           perform p_system_doclinks_add('STATEMENT',sp.ID,'TRANSACTIONLOG_STAGES',nTRANSACTIONLOG_STAGESID);
       end loop; 
       
    END LOOP; 
    return 'Документ проведён в учёте';  
end;
$body$
LANGUAGE 'plpgsql'
VOLATILE
CALLED ON NULL INPUT
SECURITY INVOKER
COST 100;

ALTER FUNCTION public.p_action_statement_to_transactionlog (id bigint, uid bigint)
  OWNER TO magicbox;